<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Pedro-Style Demo — FAT Build (AI, Level Loader, Parkour, Bullet-Time)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{ --bg1:#0b0b0f; --bg2:#16161a; --accent:#00f2e8; }
  html,body{height:100%; margin:0; background:var(--bg1); color:#ddd; font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  canvas{display:block; margin:0 auto; background:transparent; image-rendering: optimizeSpeed;}
  .hint{ position:fixed; left:12px; bottom:12px; background:rgba(0,0,0,0.45); padding:8px 10px; border-radius:8px; font-size:13px; color:#eee; backdrop-filter: blur(4px); }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hint">WASD move • Mouse aim • LMB shoot • RMB bullet-time • Space jump • K dash • N/P level • R restart</div>

<script>
/* ============================================================
   Pedro-Style FAT Build
   - Enemy AI (patrol, alert, shoot)
   - Level loader (multiple sections)
   - Parkour, bullet-time, combo, scoring
   - Big single-file HTML/JS
   ============================================================ */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function fit(){
  const ratio = 16/9; let w = Math.min(window.innerWidth, 1400); let h = Math.min(window.innerHeight, 820);
  if(w/h > ratio) w = Math.round(h*ratio); else h = Math.round(w/ratio);
  canvas.width = w; canvas.height = h;
}
fit(); window.addEventListener('resize', fit);

CanvasRenderingContext2D.prototype.roundRectPath = function(x,y,w,h,r=6){ const r0 = Math.min(r, w/2, h/2); this.beginPath(); this.moveTo(x + r0, y); this.arcTo(x + w, y, x + w, y + h, r0); this.arcTo(x + w, y + h, x, y + h, r0); this.arcTo(x, y + h, x, y, r0); this.arcTo(x, y, x + w, y, r0); this.closePath(); };

/* INPUT */
const keys = {};
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);
let mouse = {x:0,y:0,down:false,right:false};
canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top; });
canvas.addEventListener('mousedown', e=>{ if(e.button===0) mouse.down=true; if(e.button===2) mouse.right=true; });
canvas.addEventListener('mouseup', e=>{ if(e.button===0) mouse.down=false; if(e.button===2) mouse.right=false; });
canvas.addEventListener('contextmenu', e=> e.preventDefault());

/* TIME */
let last = performance.now(); let timeScale = 1;

/* WORLD & CAMERA */
const world = { width: 3200, height: 900, camX:0, camY:0 }; // large world
const camera = { shake:0 };
function applyCamera(){ if(camera.shake>0){ const s=camera.shake; const rx=(Math.random()*2-1)*s, ry=(Math.random()*2-1)*s; ctx.translate(-world.camX + rx, -world.camY + ry); camera.shake = Math.max(0, camera.shake - 0.6); } else { ctx.translate(-world.camX, -world.camY); } }
function updateCamera(){ // follow player smoothly and clamp to world
  const targetX = clamp(player.x + player.w/2 - canvas.width/2, 0, world.width - canvas.width);
  const targetY = clamp(player.y + player.h/2 - canvas.height/2, 0, world.height - canvas.height);
  world.camX = lerp(world.camX, targetX, 0.12);
  world.camY = lerp(world.camY, targetY, 0.12);
}

/* UTIL */
function clamp(v,a,b){return Math.max(a, Math.min(b, v));}
function lerp(a,b,t){return a + (b-a)*t;}

/* PARTICLES */
class Particle{ constructor(x,y,vx,vy,life,size,color,fade=true){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.max=life; this.size=size; this.color=color; this.fade=fade; } update(dt){ this.vy += 0.8 * dt; this.x += this.vx * dt; this.y += this.vy * dt; this.life -= dt; } draw(ctx){ if(this.life<=0) return; const t = clamp(this.life/this.max,0,1); ctx.save(); ctx.globalAlpha = this.fade ? t : 1; ctx.beginPath(); ctx.shadowBlur = Math.min(20, this.size*3); ctx.shadowColor = this.color; ctx.fillStyle = this.color; ctx.arc(this.x, this.y, this.size*(0.5 + t*0.5), 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; ctx.restore(); }}
const particles = [];
function spawnParticles(x,y,count,spread=2,speed=2,colors=['#fff','#ccc'],size=3,life=20){ for(let i=0;i<count;i++){ const ang=Math.random()*Math.PI*2; const r=Math.random()*speed*spread; const vx=Math.cos(ang)*r, vy=Math.sin(ang)*r - Math.random()*1.2; const col = colors[Math.floor(Math.random()*colors.length)]; particles.push(new Particle(x+(Math.random()-0.5)*6, y+(Math.random()-0.5)*6, vx, vy, life*(0.6+Math.random()*0.8), size*(0.4+Math.random()*1.6), col)); }}

/* TRAIL */
class TrailPoint{ constructor(x,y,a){ this.x=x; this.y=y; this.a=a; this.life=18; }}
const playerTrail = [];

/* BULLETS (player) */
class Bullet{ constructor(x,y,angle,speed=32, owner='player'){ this.x=x; this.y=y; this.vx=Math.cos(angle)*speed; this.vy=Math.sin(angle)*speed; this.life=60; this.trail=[]; this.radius=3; this.owner = owner; } update(dt){ this.x += this.vx * dt; this.y += this.vy * dt; this.vy += 0.12 * dt; this.trail.push({x:this.x,y:this.y}); if(this.trail.length>10) this.trail.shift(); this.life -= dt; } draw(ctx){ ctx.save(); ctx.lineWidth = 2; ctx.beginPath(); for(let i=0;i<this.trail.length;i++){ const p=this.trail[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); } ctx.strokeStyle = this.owner==='player' ? 'rgba(0,230,220,0.25)' : 'rgba(255,150,120,0.22)'; ctx.stroke(); ctx.beginPath(); ctx.shadowBlur = 12; ctx.shadowColor = this.owner==='player' ? '#00f2e8' : '#ff8c66'; ctx.fillStyle = this.owner==='player' ? '#bfffff' : '#ffb3a0'; ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; ctx.restore(); }}
const bullets = [];
function spawnBullet(x,y,angle, owner='player'){ bullets.push(new Bullet(x,y,angle, owner==='player'?28:20, owner)); spawnParticles(x + Math.cos(angle)*8, y + Math.sin(angle)*8, 8, 1.2, 2.2, owner==='player' ? ['#fff','#ffd'] : ['#fff','#ffb3a0'], 2, 12); camera.shake = Math.max(camera.shake, 6); }

/* PLAYER */
class Player{ constructor(){ this.x=140; this.y=world.height - 160; this.w=44; this.h=64; this.vx=0; this.vy=0; this.speed=7.2; this.jumpPow=-14; this.onGround=false; this.coyote=0; this.pose=0; this.shootCooldown=0; this.facing=1; this.hp=5; this.dodge=0; this.prevX=this.x; this.prevY=this.y; this.wallSlide=false; this.wallDir=0; this.bulletTimeMeter=100; } update(dt){ const bulletTimeActive = mouse.right && this.bulletTimeMeter > 6; timeScale = bulletTimeActive ? 0.18 : (keys['shift'] ? 0.28 : 1); if(bulletTimeActive){ this.bulletTimeMeter = Math.max(0, this.bulletTimeMeter - 18 * dt); } else { this.bulletTimeMeter = Math.min(100, this.bulletTimeMeter + 8 * dt); } dt *= timeScale; const left = keys['a']; const right = keys['d']; const dir = (left?-1:0) + (right?1:0); this.prevX = this.x; this.prevY = this.y; this.vx = lerp(this.vx, dir * this.speed, 0.24); this.vy += 0.9; // gravity
    // wall detection
    this.wallSlide = false; this.wallDir = 0;
    if(this.x <= 4) { this.wallSlide = true; this.wallDir = -1; }
    if(this.x + this.w >= world.width - 4) { this.wallSlide = true; this.wallDir = 1; }
    for(const p of currentLevel.platforms){ const pyTop = p.y; const pyBottom = p.y + p.h; const playerMid = this.y + this.h*0.5; if(playerMid > pyTop - 2 && playerMid < pyBottom + 2){ if(Math.abs((this.x + this.w) - p.x) < 8 && this.x + this.w <= p.x + 8){ this.wallSlide = true; this.wallDir = -1; } if(Math.abs(this.x - (p.x + p.w)) < 8 && this.x >= p.x + p.w - 8){ this.wallSlide = true; this.wallDir = 1; } } }
    if(this.wallSlide && this.vy > 0){ this.vy = Math.min(this.vy, 1.8); }
    // jump
    if(keys[' '] && (this.onGround || this.coyote > 0 || this.wallSlide)){
      if(this.wallSlide && !this.onGround){ this.vy = this.jumpPow * 0.9; this.vx = 10 * -this.wallDir; this.wallSlide = false; camera.shake = Math.max(camera.shake, 8); spawnParticles(this.x + this.w/2, this.y + this.h/2, 10, 1.6, 2.2, ['#fff','#cce'], 3, 16); } else { this.vy = this.jumpPow; this.onGround=false; this.coyote=0; camera.shake = Math.max(camera.shake,6); spawnParticles(this.x + this.w/2, this.y + this.h + 6, 8, 1.5, 1.6, ['#fff','#ddd'], 3, 14); } }
    // dash
    if(keys['k']){ if(this.dodge <= 0){ this.dodge = 10; this.facing = (mouse.x + world.camX < this.x + this.w/2) ? -1 : 1; camera.shake = Math.max(camera.shake, 10); spawnParticles(this.x + this.w/2, this.y + this.h/2, 10, 1.6, 2.6, ['#fff','#aaf'], 3.2, 18); } }
    this.x += (this.vx + (this.dodge > 0 ? 8*Math.sign(this.facing) : 0)) * dt; this.y += this.vy * dt; if(this.dodge > 0) this.dodge = Math.max(0, this.dodge - 30 * dt);
    // collide platforms top-only
    this.onGround = false;
    for(const p of currentLevel.platforms){ if(this.prevY + this.h <= p.y && this.y + this.h >= p.y && this.x + this.w > p.x && this.x < p.x + p.w){ this.y = p.y - this.h; this.vy = 0; this.onGround = true; this.coyote = 10; } }
    if(!this.onGround) this.coyote = Math.max(0, this.coyote - 1 * dt);
    this.x = clamp(this.x, 4, world.width - this.w - 4);
    // shooting
    this.shootCooldown -= dt * 30;
    if(mouse.down && this.shootCooldown <= 0){ this.shootCooldown = 4; const px = this.x + this.w/2; const py = this.y + this.h/2; const angle = Math.atan2((mouse.y + world.camY) - py, (mouse.x + world.camX) - px); spawnBullet(px + Math.cos(angle)*8, py + Math.sin(angle)*8, angle, 'player'); setTimeout(()=> spawnBullet(px + Math.cos(angle)*8, py + Math.sin(angle)*8, angle, 'player'), 40); }
    // pose & trail
    this.pose = lerp(this.pose, 0, 0.12);
    playerTrail.unshift(new TrailPoint(this.x + this.w/2, this.y + this.h/2, this.pose)); if(playerTrail.length>14) playerTrail.pop(); }
  draw(ctx){ ctx.save(); ctx.globalAlpha = 0.28; ctx.beginPath(); ctx.ellipse(this.x + this.w/2, this.y + this.h + 6, this.w*0.7, 8, 0,0,Math.PI*2); ctx.fillStyle='#000'; ctx.fill(); ctx.globalAlpha = 1; ctx.restore(); ctx.save(); for(let i=playerTrail.length-1;i>=0;i--){ const p=playerTrail[i]; const t=(i/playerTrail.length); ctx.globalAlpha = lerp(0.04,0.35,1-t); drawPlayerSilhouette(ctx, p.x - this.w/2, p.y - this.h/2, this.w, this.h, p.a, 2 + t*4, true); ctx.globalAlpha = 1; } ctx.restore(); drawPlayerSilhouette(ctx, this.x, this.y, this.w, this.h, this.pose, 0, false); ctx.save(); ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.roundRectPath(this.x - 4, this.y - 12, this.w + 8, 6, 3); ctx.fill(); ctx.fillStyle='#00f2e8'; ctx.fillRect(this.x - 4, this.y - 12, (this.bulletTimeMeter/100) * (this.w + 8), 6); ctx.restore(); }}
const player = new Player();

function drawPlayerSilhouette(ctx,x,y,w,h,rot=0,outlineBoost=0,ghost=false){ ctx.save(); ctx.translate(x + w/2, y + h/2); ctx.rotate(rot); ctx.translate(-w/2, -h/2); const bodyGr = ctx.createLinearGradient(0,0,0,h); bodyGr.addColorStop(0, ghost? 'rgba(255,255,255,0.05)' : '#ffd965'); bodyGr.addColorStop(1, ghost? 'rgba(255,255,255,0.01)' : '#e6b400'); if(!ghost){ ctx.fillStyle='#0b0b0d'; ctx.roundRectPath(-4-outlineBoost, -6-outlineBoost, w+8+outlineBoost*2, h+12+outlineBoost*2, 10 + outlineBoost); ctx.fill(); } ctx.fillStyle = bodyGr; ctx.roundRectPath(0,0,w,h,10); ctx.fill(); if(!ghost){ ctx.fillStyle='rgba(0,0,0,0.06)'; ctx.roundRectPath(4, h*0.2, w-8, h*0.6, 8); ctx.fill(); } if(!ghost){ ctx.save(); ctx.beginPath(); ctx.shadowBlur = 18; ctx.shadowColor = 'rgba(0,200,190,0.25)'; ctx.fillStyle = '#091213'; ctx.roundRectPath(w*0.4, h*0.18, w*0.4, h*0.22, 6); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle='rgba(0,250,230,0.12)'; ctx.roundRectPath(w*0.43, h*0.2, w*0.18, h*0.12, 4); ctx.fill(); ctx.restore(); } if(!ghost){ ctx.lineWidth = 2; ctx.strokeStyle = '#0b0b0d'; ctx.roundRectPath(0,0,w,h,10); ctx.stroke(); } ctx.restore(); }

/* ENEMY AI */
class Enemy{ constructor(x,y, patrolRange=120){ this.x=x; this.y=y; this.w=44; this.h=56; this.hp=3; this.alive=true; this.deathTimer=0; this.pulse=Math.random()*100; this.state='patrol'; this.patrolCenter = x; this.patrolRange = patrolRange; this.speed = 1.8 + Math.random()*0.8; this.dir = Math.random()<0.5? -1:1; this.cooldown = 0; this.shootCooldown = 0; this.aggroRange = 500; this.returning=false; }
  update(dt){ if(!this.alive){ this.deathTimer -= dt; return; } this.pulse += dt*12; // state machine
    // simple distance to player
    const px = player.x + player.w/2; const py = player.y + player.h/2; const ex = this.x + this.w/2; const ey = this.y + this.h/2; const dist = Math.hypot(px - ex, py - ey);
    // if close and line of sight roughly, go alert
    if(dist < this.aggroRange && Math.abs(py - ey) < 120){ this.state = 'alert'; }
    // state behaviors
    if(this.state === 'patrol'){
      // walk back and forth
      this.x += this.dir * this.speed * dt;
      if(Math.abs(this.x - this.patrolCenter) > this.patrolRange) this.dir *= -1;
      // small chance to peek (idle)
    } else if(this.state === 'alert'){
      // face player and shoot periodically
      const angle = Math.atan2(py - ey, px - ex);
      this.shootCooldown -= dt * 30;
      if(this.shootCooldown <= 0){ this.shootCooldown = 36; // fire interval
        spawnBullet(ex, ey, angle + (Math.random()-0.5)*0.06, 'enemy');
      }
      // advance slowly toward player
      const chaseSpeed = 1.2; if(px < this.x) this.x -= chaseSpeed * dt; else this.x += chaseSpeed * dt;
      // if far, return to patrol
      if(dist > this.aggroRange * 1.4) { this.state = 'patrol'; }
    }
    // check collisions with player bullets
    for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; if(b.owner !== 'player') continue; if(b.x > this.x && b.x < this.x + this.w && b.y > this.y && b.y < this.y + this.h){ this.hp--; bullets.splice(i,1); spawnParticles(b.x,b.y,12,1.8,3,['#ff6b6b','#ffb3b3'],3,26); camera.shake = Math.max(camera.shake, 10); comboTimer = 120; combo += 1; bestCombo = Math.max(bestCombo, combo); addScore(150, this.x + this.w/2, this.y); if(this.hp <= 0){ this.alive = false; this.deathTimer = 26; spawnParticles(this.x+this.w/2,this.y+this.h/2,36,2.6,3.6,['#ff8c66','#aa0000','#ff4d4d'],4,36); } } }
  }
  draw(ctx){ if(!this.alive){ if(this.deathTimer<=0) return; ctx.save(); ctx.globalAlpha = clamp(this.deathTimer/26,0,1); }
    ctx.save(); const g = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h); g.addColorStop(0,'#ff6b6b'); g.addColorStop(1,'#aa2222'); ctx.fillStyle = g; ctx.roundRectPath(this.x, this.y, this.w, this.h, 8); ctx.fill(); const eyeY = this.y + this.h*0.28; const eyeX1 = this.x + this.w*0.28; const eyeX2 = this.x + this.w*0.72; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(eyeX1, eyeY, 6,0,Math.PI*2); ctx.arc(eyeX2, eyeY, 6,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#400'; ctx.beginPath(); ctx.arc(eyeX1,eyeY,3,0,Math.PI*2); ctx.arc(eyeX2,eyeY,3,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='rgba(255,200,200,0.06)'; ctx.arc(eyeX1,eyeY,14,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='rgba(255,200,200,0.06)'; ctx.arc(eyeX2,eyeY,14,0,Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.roundRectPath(this.x,this.y,this.w,this.h,8); ctx.stroke(); ctx.restore(); if(!this.alive) ctx.restore(); }}

const enemies = [];

/* LEVEL LOADER */
const levels = [
  // level 0: intro, simple
  { name: 'Warehouse Intro', width: 1400, platforms: [ {x:0,y:760,w:1400,h:40}, {x:240,y:620,w:240,h:14}, {x:560,y:520,w:200,h:14}, {x:900,y:640,w:220,h:14} ], pans: [ {x:420,y:700,r:36}, {x:760,y:560,r:36} ], enemySpawns: [ {x:900,y:700}, {x:1200,y:700} ], playerStart: {x:120,y:700} },
  // level 1: vertical
  { name: 'Office Tower', width: 2200, platforms: [ {x:0,y:760,w:2200,h:40}, {x:300,y:640,w:180,h:14}, {x:540,y:560,w:180,h:14}, {x:820,y:480,w:160,h:14}, {x:1100,y:420,w:220,h:14}, {x:1420,y:520,w:200,h:14}, {x:1760,y:600,w:220,h:14}], pans: [ {x:520,y:520,r:34},{x:1400,y:500,r:36}], enemySpawns: [{x:700,y:720},{x:1300,y:480},{x:1700,y:560}], playerStart:{x:120,y:700} },
  // level 2: long and wide
  { name: 'Silo Run', width: 3200, platforms: [ {x:0,y:760,w:3200,h:40}, {x:420,y:620,w:220,h:14}, {x:860,y:560,w:400,h:14}, {x:1400,y:640,w:360,h:14}, {x:1900,y:520,w:300,h:14}, {x:2400,y:600,w:300,h:14}, {x:2800,y:520,w:240,h:14}], pans: [{x:860,y:520,r:36},{x:1900,y:500,r:36},{x:2400,y:560,r:34}], enemySpawns: [{x:820,y:540},{x:1500,y:620},{x:2100,y:520},{x:2700,y:540}], playerStart:{x:120,y:700} },
  // level 3: gauntlet
  { name: 'The Gauntlet', width: 2000, platforms: [ {x:0,y:760,w:2000,h:40}, {x:300,y:700,w:140,h:14}, {x:480,y:640,w:140,h:14}, {x:660,y:580,w:140,h:14}, {x:840,y:520,w:140,h:14}, {x:1020,y:460,w:140,h:14}, {x:1200,y:520,w:200,h:14}, {x:1540,y:640,w:300,h:14}], pans: [{x:540,y:620,r:34},{x:980,y:500,r:36}], enemySpawns:[{x:420,y:720},{x:760,y:620},{x:1100,y:500},{x:1480,y:720}], playerStart:{x:120,y:700} }
];
let currentLevelIndex = 0;
let currentLevel = levels[currentLevelIndex];

function loadLevel(idx){ currentLevelIndex = clamp(idx, 0, levels.length - 1); currentLevel = levels[currentLevelIndex]; world.width = currentLevel.width; // reposition player
  player.x = currentLevel.playerStart.x; player.y = currentLevel.playerStart.y; player.vx = 0; player.vy = 0; bullets.length = 0; particles.length = 0; enemies.length = 0; for(const s of currentLevel.enemySpawns){ enemies.push(new Enemy(s.x, s.y, 120 + Math.random()*120)); } }
loadLevel(0);

/* PANS draw uses currentLevel.pans */
function drawPans(ctx){ for(const p of currentLevel.pans){ ctx.save(); const gr = ctx.createRadialGradient(p.x - p.r*0.3, p.y - p.r*0.4, p.r*0.1, p.x, p.y, p.r); gr.addColorStop(0,'#fff'); gr.addColorStop(0.4,'#ddd'); gr.addColorStop(0.7,'#aaa'); gr.addColorStop(1,'#666'); ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(40,40,40,0.7)'; ctx.stroke(); ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.arc(p.x - p.r*0.12, p.y - p.r*0.18, p.r*0.6, 0, Math.PI*2); ctx.fill(); ctx.restore(); } }

/* BACKGROUND & PLATFORMS */
function drawBackground(ctx){ const bg = ctx.createLinearGradient(0,0,0,canvas.height); bg.addColorStop(0,'#0b0b0f'); bg.addColorStop(1,'#151517'); ctx.fillStyle = bg; ctx.fillRect(0,0,world.width,canvas.height); ctx.save(); ctx.globalCompositeOperation = 'overlay'; const v = ctx.createRadialGradient(world.camX + canvas.width/2, world.camY + canvas.height/2, canvas.height*0.2, world.camX + canvas.width/2, world.camY + canvas.height/2, canvas.height*0.9); v.addColorStop(0,'rgba(0,0,0,0)'); v.addColorStop(1,'rgba(0,0,0,0.45)'); ctx.fillStyle = v; ctx.fillRect(world.camX, world.camY, canvas.width, canvas.height); ctx.restore(); // floor
  ctx.save(); const floorGrad = ctx.createLinearGradient(0, canvas.height - 120, 0, canvas.height); floorGrad.addColorStop(0,'#161616'); floorGrad.addColorStop(1,'#0b0b0b'); ctx.fillStyle = floorGrad; ctx.fillRect(0, canvas.height - 120 + world.camY, world.width, 120); ctx.restore(); // platforms (world-space)
  ctx.save(); for(const p of currentLevel.platforms){ ctx.fillStyle = 'rgba(20,20,20,0.98)'; ctx.roundRectPath(p.x, p.y, p.w, p.h, 6); ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.stroke(); } ctx.restore(); }

/* SCORING */
let score = 0; let combo = 0; let comboTimer = 0; let bestCombo = 0; const floatingTexts = [];
function addScore(amount, x, y){ const mult = Math.max(1, 1 + Math.floor(combo/3)*0.25); const gained = Math.floor(amount * mult); score += gained; floatingTexts.push({x,y,text:'+'+gained, life:60}); }
function onEnemyHit(enemy){ comboTimer = 120; combo += 1; bestCombo = Math.max(bestCombo, combo); addScore(150, enemy.x + enemy.w/2, enemy.y); }
function updateFloating(dt){ for(let i=floatingTexts.length-1;i>=0;i--){ const t=floatingTexts[i]; t.y -= 0.4 * dt; t.life -= dt; if(t.life<=0) floatingTexts.splice(i,1); } }

/* UPDATE */
function update(dt){ player.update(dt); // bullets
  for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.update(dt);
    // ricochet with pans
    for(const p of currentLevel.pans){ const dx=b.x-p.x, dy=b.y-p.y; const dist=Math.hypot(dx,dy); if(dist < p.r + b.radius){ const nx = dx/dist, ny = dy/dist; const dot = b.vx*nx + b.vy*ny; b.vx -= 2*dot*nx; b.vy -= 2*dot*ny; b.life += 18; spawnParticles(b.x,b.y,6,1.6,3,['#fff','#ffd','#ffd1'],2,16); camera.shake = Math.max(camera.shake,8); } }
    // enemy vs player bullets handled in enemy update, enemy bullets hitting player below
    if(b.owner === 'enemy'){ if(b.x > player.x && b.x < player.x + player.w && b.y > player.y && b.y < player.y + player.h){ // player hit
        bullets.splice(i,1); player.hp -= 1; spawnParticles(player.x + player.w/2, player.y + player.h/2, 10, 1.6, 2.6, ['#ffb3a0','#ff8c66'], 3.2, 18); camera.shake = Math.max(camera.shake, 10); if(player.hp <= 0){ // respawn at start
          setTimeout(()=> loadLevel(currentLevelIndex), 200); }
      } }
    if(b.life <= 0 || b.x < -80 || b.x > world.width + 80 || b.y < -400 || b.y > world.height + 400) bullets.splice(i,1);
  }
  // particles
  for(let i=particles.length-1;i>=0;i--){ particles[i].update(dt); if(particles[i].life <= 0) particles.splice(i,1); }
  // enemies
  for(const e of enemies) e.update(dt);
  // combo timer
  if(comboTimer > 0){ comboTimer -= dt; if(comboTimer <= 0) combo = 0; }
  updateFloating(dt);
  // camera
  updateCamera(); }

/* RENDER */
function render(){ // motion blur base
  ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle = 'rgba(5,8,12,0.45)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); ctx.save(); applyCamera(); drawBackground(ctx); drawPans(ctx); particles.forEach(p=>p.draw(ctx)); bullets.forEach(b=>b.draw(ctx)); const drawables = [...enemies, player]; drawables.sort((a,b)=> (a.x||0) - (b.x||0)); for(const d of drawables) d.draw(ctx); // bullet-time reticle
  if(mouse.right){ ctx.save(); ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,230,220,0.65)'; ctx.arc(mouse.x + world.camX, mouse.y + world.camY, 36, 0, Math.PI*2); ctx.stroke(); ctx.restore(); }
  drawHUD(ctx);
  // floating texts (world-space)
  ctx.save(); for(const ft of floatingTexts){ ctx.globalAlpha = clamp(ft.life/60,0,1); ctx.font = 'bold 16px sans-serif'; ctx.fillStyle = '#fff'; ctx.fillText(ft.text, ft.x, ft.y); } ctx.restore(); ctx.restore(); }

function drawHUD(ctx){ ctx.save(); // crosshair in screen space
  ctx.setTransform(1,0,0,1,0,0); ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,230,220,0.9)'; ctx.moveTo(mouse.x - 10, mouse.y); ctx.lineTo(mouse.x + 10, mouse.y); ctx.moveTo(mouse.x, mouse.y - 10); ctx.lineTo(mouse.x, mouse.y + 10); ctx.stroke(); ctx.beginPath(); ctx.fillStyle = 'rgba(0,230,220,0.9)'; ctx.arc(mouse.x, mouse.y, 3, 0, Math.PI*2); ctx.fill(); // HP
  const hp = player.hp; for(let i=0;i<5;i++){ ctx.beginPath(); ctx.fillStyle = i<hp ? '#ffdb4d' : 'rgba(255,255,255,0.06)'; ctx.roundRectPath(12 + i*26, 12, 20, 12, 4); ctx.fill(); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.stroke(); }
  // score & combo
  ctx.font = '16px sans-serif'; ctx.fillStyle = '#fff'; ctx.fillText('Score: ' + score, canvas.width - 160, 28); ctx.fillStyle = combo > 0 ? '#ffd965' : '#888'; ctx.fillText('Combo: ' + combo + ' (x' + (1 + Math.floor(combo/3)*0.25).toFixed(2) + ')', canvas.width - 380, 28); ctx.fillStyle = '#aaa'; ctx.fillText('Level: ' + currentLevel.name, canvas.width/2 - 80, 28); // bullet-time meter
  ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.roundRectPath(12, canvas.height - 28, 160, 12, 6); ctx.fill(); ctx.fillStyle = '#00f2e8'; ctx.fillRect(12, canvas.height - 28, (player.bulletTimeMeter/100)*160, 12);
  ctx.restore(); }

/* MAIN LOOP */
function loop(t){ const rawDt = (t - last) / (1000/60); last = t; const dt = clamp(rawDt, 0, 4); update(dt); render(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

/* POLISH */
setInterval(()=>{ const p = currentLevel.pans[Math.floor(Math.random()*currentLevel.pans.length)]; if(p) spawnParticles(p.x + (Math.random()-0.5)*10, p.y + (Math.random()-0.5)*10, 6, 1.5, 1.8, ['#fff','#ffd','rgba(255,200,180,0.8)'], 1.6, 12); }, 600);

/* CONTROLS: N/P to change level, R restart */
window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='n'){ loadLevel(currentLevelIndex+1); } if(e.key.toLowerCase()==='p'){ loadLevel(currentLevelIndex-1); } if(e.key.toLowerCase()==='r'){ loadLevel(currentLevelIndex); score = 0; combo = 0; comboTimer=0; } });

/* SCORE helpers used in enemy hit earlier */
function addScore(amount,x,y){ const mult = Math.max(1, 1 + Math.floor(combo/3)*0.25); const gained = Math.floor(amount * mult); score += gained; floatingTexts.push({x,y,text:'+'+gained, life:60}); }

/* initial camera clamp world size default */n
</script>
</body>
</html>
