<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pedro-Style Engine</title>
<style>
    body { margin:0; background:#111; overflow:hidden; }
    canvas { display:block; margin:0 auto; background:#222; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// ============================================================
//  Pedro-Style Engine v1.0
// ============================================================

// -------------------- CANVAS --------------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = 1000;
canvas.height = 550;

// -------------------- INPUT --------------------
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

let mouse = {x:0, y:0, down:false};
canvas.addEventListener("mousemove", e=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});
canvas.addEventListener("mousedown", ()=> mouse.down = true);
canvas.addEventListener("mouseup", ()=> mouse.down = false);

// -------------------- TIME --------------------
let lastTime = 0;
let timeScale = 1;

// -------------------- CAMERA --------------------
let camera = {x:0, y:0, shake:0};
function applyCamera() {
    if(camera.shake>0) {
        camera.shake -= 0.8;
        ctx.translate((Math.random()-0.5)*camera.shake, (Math.random()-0.5)*camera.shake);
    }
}

// ============================================================
//  UTILITIES
// ============================================================
function lerp(a,b,t){return a+(b-a)*t;}
function clamp(v,min,max){return Math.max(min,Math.min(max,v));}

// ============================================================
//  PARTICLE SYSTEM
// ============================================================
class Particle {
    constructor(x,y,vx,vy,life,size,color){
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.life = life; this.maxLife = life;
        this.size = size;
        this.color = color;
    }
    update(dt){
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vy += 0.5*dt; // gravity
        this.life -= dt;
    }
    draw(ctx){
        ctx.globalAlpha = this.life/this.maxLife;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}
const particles = [];
function spawnParticles(x,y,count,colors,speed=2,size=3,life=30){
    for(let i=0;i<count;i++){
        const angle = Math.random()*Math.PI*2;
        const speedRand = Math.random()*speed;
        const vx = Math.cos(angle)*speedRand;
        const vy = Math.sin(angle)*speedRand;
        const color = colors[Math.floor(Math.random()*colors.length)];
        particles.push(new Particle(x,y,vx,vy,life*Math.random(),size*Math.random()+1,color));
    }
}

// ============================================================
//  BULLETS
// ============================================================
class Bullet {
    constructor(x,y,angle){
        this.x = x; this.y = y;
        this.vx = Math.cos(angle)*20;
        this.vy = Math.sin(angle)*20;
        this.life = 50;
        this.trail = [];
    }
    update(dt){
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.trail.push({x:this.x,y:this.y});
        if(this.trail.length>8) this.trail.shift();
        this.life--;
    }
    draw(ctx){
        // trail
        ctx.strokeStyle = "rgba(0,255,255,0.5)";
        ctx.beginPath();
        for(let i=0;i<this.trail.length;i++){
            const t = this.trail[i];
            ctx.lineTo(t.x,t.y);
        }
        ctx.stroke();
        // bullet
        ctx.fillStyle = "#0ff";
        ctx.fillRect(this.x-2,this.y-1,4,2);
    }
}
const bullets = [];
function spawnBullet(x,y,angle){
    bullets.push(new Bullet(x,y,angle));
    camera.shake = 5;
}

// ============================================================
//  PLAYER
// ============================================================
class Player {
    constructor(){
        this.x = 100; this.y = 300;
        this.w = 40; this.h = 60;
        this.vx = 0; this.vy = 0;
        this.speed = 6; this.jump=-14;
        this.onGround = false;
        this.coyote = 0;
        this.angle = 0; // rotation for flips
        this.knockback = 0;
        this.shootTimer = 0;

        // STATE MACHINE LAYERS
        this.movement = "idle";  // idle/run/jump/fall/dive
        this.action = "none";    // shoot/hit/etc
        this.pose = 0;           // rotation for flips
        this.effect = "none";    // slowmo/etc
    }

    update(dt){
        // ---- TIME SCALE ----
        timeScale = keys["shift"] ? 0.25 : 1;
        dt*=timeScale;

        // ---- INPUT ----
        let dir = (keys["a"]?-1:0)+(keys["d"]?1:0);

        // ---- MOVEMENT STATE MACHINE ----
        if(this.movement==="idle"||this.movement==="run"){
            this.vx = dir*this.speed;
            this.vy += 0.8;
            if(!this.onGround) this.movement="fall";
        }
        if(this.movement==="jump"){
            this.vy += 0.8;
            if(this.vy>0) this.movement="fall";
        }
        if(this.movement==="fall"){
            this.vy += 0.8;
            if(this.onGround) this.movement="idle";
        }
        if(this.movement==="dive"){
            this.vy += 0.5;
        }

        // ---- JUMP ----
        if(keys[" "] && (this.onGround||this.coyote>0)){
            this.vy = this.jump;
            this.onGround=false;
            this.coyote=0;
            this.movement="jump";
            camera.shake = 8;
        }

        // ---- APPLY MOVEMENT ----
        this.x += (this.vx+this.knockback)*dt;
        this.y += this.vy*dt;
        this.knockback *= 0.85;

        // ---- GROUND ----
        this.onGround=false;
        if(this.y+this.h>canvas.height-20){
            this.y=canvas.height-20-this.h;
            this.vy=0;
            this.onGround=true;
            this.movement="idle";
        }

        // ---- WALLS ----
        this.x = clamp(this.x,0,canvas.width-this.w);

        // ---- SHOOT ----
        this.shootTimer -= dt;
        if(mouse.down && this.shootTimer<=0){
            this.shootTimer = 4; // fire rate
            const px=this.x+this.w/2, py=this.y+this.h/2;
            const angle = Math.atan2(mouse.y-py, mouse.x-px);
            spawnBullet(px,py-10,angle);
            spawnBullet(px,py+10,angle);
            this.action="shoot";
        } else {
            this.action="none";
        }

        // ---- FLIP ROTATION ----
        if(this.movement==="jump"||this.movement==="dive"){
            this.pose += 0.4*dt;
        } else {
            this.pose *= 0.8;
        }
    }

    draw(ctx){
        ctx.save();
        ctx.translate(this.x+this.w/2,this.y+this.h/2);
        ctx.rotate(this.pose);
        ctx.fillStyle="#ffd800";
        ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h);
        ctx.restore();
    }
}
const player = new Player();

// ============================================================
//  ENEMIES
// ============================================================
class Enemy {
    constructor(x,y){
        this.x = x; this.y = y;
        this.w = 40; this.h = 60;
        this.hp = 3;
        this.alive = true;
        this.deathTimer=0;
    }
    update(dt){
        if(!this.alive && this.deathTimer>0) this.deathTimer--;
    }
    draw(ctx){
        if(this.alive){
            ctx.fillStyle="#ff3333";
            ctx.fillRect(this.x,this.y,this.w,this.h);
        } else if(this.deathTimer>0){
            ctx.fillStyle=`rgba(255,0,0,${this.deathTimer/40})`;
            ctx.fillRect(this.x,this.y,this.w,this.h);
        }
    }
}
const enemies = [new Enemy(700,330)];

// ============================================================
//  PANS (ricochet objects)
// ============================================================
const pans = [
    {x:400, y:380, r:35},
    {x:550, y:260, r:35}
];

// ============================================================
//  UPDATE LOOP
// ============================================================
function update(dt){
    // PLAYER
    player.update(dt);

    // BULLETS
    for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.update(dt);

        // PANS RICOCHET
        for(let p of pans){
            const dx = b.x-p.x, dy = b.y-p.y;
            const dist = Math.hypot(dx,dy);
            if(dist<p.r){
                const nx = dx/dist, ny = dy/dist;
                const dot = b.vx*nx + b.vy*ny;
                b.vx -= 2*dot*nx; b.vy -= 2*dot*ny;
                b.life += 25;
                spawnParticles(b.x,b.y,5,["#fff","#ccc"],3,2,15); // sparks
                camera.shake=10;
            }
        }

        // ENEMY HIT
        for(let en of enemies){
            if(!en.alive) continue;
            if(b.x>en.x && b.x<en.x+en.w && b.y>en.y && b.y<en.y+en.h){
                en.hp--;
                b.life=0;
                player.knockback=-Math.cos(Math.atan2(mouse.y-(player.y+player.h/2),mouse.x-(player.x+player.w/2)))*3;
                spawnParticles(b.x,b.y,8,["#aa0000","#ff0000"],4,3,20); // blood
                if(en.hp<=0){
                    en.alive=false;
                    en.deathTimer=40;
                    camera.shake=12;
                }
            }
        }

        if(b.life<=0) bullets.splice(i,1);
    }

    // PARTICLES
    for(let i=particles.length-1;i>=0;i--){
        particles[i].update(dt);
        if(particles[i].life<=0) particles.splice(i,1);
    }

    // ENEMIES
    for(let en of enemies) en.update(dt);
}

// ============================================================
//  DRAW LOOP (Layered Canvas Renderer)
// ============================================================
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    applyCamera();

    // ----- LAYER 1: BACKGROUND -----
    ctx.fillStyle="#222";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // ----- LAYER 2: STATIC DECALS (PANS) -----
    ctx.fillStyle="#ccc";
    for(let p of pans){
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fill();
    }

    // ----- LAYER 3: DYNAMIC DECALS / PARTICLES -----
    particles.forEach(p=>p.draw(ctx));

    // ----- LAYER 4: BULLETS -----
    bullets.forEach(b=>b.draw(ctx));

    // ----- LAYER 5: PLAYER -----
    player.draw(ctx);

    // ----- LAYER 6: ENEMIES -----
    enemies.forEach(e=>e.draw(ctx));

    // ----- LAYER 7: FX OVERLAYS (slow-mo tint) -----
    if(timeScale<1){
        ctx.fillStyle="rgba(0,255,255,0.1)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    ctx.restore();
}

// ============================================================
//  GAME LOOP
// ============================================================
function loop(t){
    const dt = ((t-lastTime)/16.67);
    lastTime=t;

    update(dt);
    draw();

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
