<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pedro-Style FAT Demo</title>
<style>
html,body{margin:0;background:#111;overflow:hidden}
canvas{display:block;margin:auto;background:#1a1a1a}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
// ==========================================================
// CANVAS
// ==========================================================
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
canvas.width = 1100;
canvas.height = 600;

// ==========================================================
// INPUT
// ==========================================================
const keys = {};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

const mouse={x:0,y:0,down:false};
canvas.onmousemove=e=>{
  const r=canvas.getBoundingClientRect();
  mouse.x=e.clientX-r.left;
  mouse.y=e.clientY-r.top;
};
canvas.onmousedown=()=>mouse.down=true;
canvas.onmouseup=()=>mouse.down=false;

// ==========================================================
// UTILS
// ==========================================================
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

// ==========================================================
// WORLD / LEVEL
// ==========================================================
const platforms=[
  {x:0,y:540,w:2000,h:60},
  {x:300,y:420,w:300,h:20},
  {x:700,y:330,w:250,h:20}
];

// ==========================================================
// BULLETS
// ==========================================================
class Bullet{
  constructor(x,y,a,enemy=false){
    this.x=x;this.y=y;
    this.vx=Math.cos(a)*18;
    this.vy=Math.sin(a)*18;
    this.life=60;
    this.enemy=enemy;
  }
  update(){
    this.x+=this.vx;
    this.y+=this.vy;
    this.life--;
  }
  draw(){
    ctx.fillStyle=this.enemy?"#ff5555":"#00ffff";
    ctx.fillRect(this.x-2,this.y-2,4,4);
  }
}
const bullets=[];

// ==========================================================
// PLAYER
// ==========================================================
class Player{
  constructor(){
    this.x=100;this.y=300;
    this.w=30;this.h=60;
    this.vx=0;this.vy=0;
    this.onGround=false;
    this.cooldown=0;
  }
  update(){
    const slow = keys["shift"] ? 0.25 : 1;

    let dir=(keys["a"]?-1:0)+(keys["d"]?1:0);
    this.vx=dir*6*slow;
    this.vy+=0.8*slow;

    if(keys[" "]&&this.onGround){
      this.vy=-14;
      this.onGround=false;
    }

    this.x+=this.vx;
    this.y+=this.vy;

    this.onGround=false;
    for(const p of platforms){
      if(this.x+this.w>p.x && this.x<p.x+p.w){
        if(this.y+this.h<=p.y+10 && this.y+this.h+this.vy>=p.y){
          this.y=p.y-this.h;
          this.vy=0;
          this.onGround=true;
        }
      }
    }

    this.cooldown--;
    if(mouse.down && this.cooldown<=0){
      const cx=this.x+this.w/2;
      const cy=this.y+this.h*0.4;
      const a=Math.atan2(mouse.y-cy,mouse.x-cx);
      bullets.push(new Bullet(cx,cy,a,false));
      this.cooldown=6;
    }
  }
}
const player=new Player();

// ==========================================================
// ENEMY
// ==========================================================
class Enemy{
  constructor(x,y){
    this.x=x;this.y=y;
    this.w=30;this.h=60;
    this.vx=0;this.vy=0;
    this.state="idle";
    this.cooldown=0;
    this.dead=false;
    this.fade=40;
    this.deathRot=(Math.random()-.5)*0.6;
  }
  update(){
    if(this.dead){
      this.fade--;
      return;
    }

    const dx=player.x-this.x;
    const dy=player.y-this.y;
    const d=Math.hypot(dx,dy);

    switch(this.state){
      case "idle":
        if(d<450) this.state="aim";
      break;
      case "aim":
        if(d<350) this.state="shoot";
      break;
      case "shoot":
        this.cooldown--;
        if(this.cooldown<=0){
          const a=Math.atan2(dy,dx);
          bullets.push(new Bullet(this.x+15,this.y+25,a,true));
          this.cooldown=60;
        }
        if(d>450) this.state="idle";
      break;
    }
  }
}
const enemies=[
  new Enemy(500,360),
  new Enemy(800,270)
];

// ==========================================================
// HUMAN DRAW
// ==========================================================
function drawHuman(ent,isEnemy=false){
  const cx=ent.x+ent.w/2;
  const cy=ent.y+ent.h*0.45;
  const ax=isEnemy?player.x+15:mouse.x;
  const ay=isEnemy?player.y+25:mouse.y;
  const ang=Math.atan2(ay-cy,ax-cx);

  ctx.save();
  ctx.translate(cx,cy);
  if(ent.dead) ctx.rotate(ent.deathRot);

  ctx.fillStyle=isEnemy?"#8b2a2a":"#f5d76e";
  roundRect(ctx,-12,-20,24,42,6);
  ctx.fill();

  ctx.beginPath();
  ctx.arc(0,-34,9,0,Math.PI*2);
  ctx.fillStyle=isEnemy?"#b33":"#ffeaa6";
  ctx.fill();

  ctx.save();
  ctx.rotate(ang);
  ctx.strokeStyle="#111";
  ctx.lineWidth=4;
  ctx.lineCap="round";
  ctx.beginPath();
  ctx.moveTo(6,-10);
  ctx.lineTo(24,-4);
  ctx.stroke();
  ctx.fillStyle="#333";
  ctx.fillRect(24,-7,12,5);
  ctx.restore();

  ctx.strokeStyle="#111";
  ctx.beginPath();
  ctx.moveTo(-6,20);
  ctx.lineTo(-8,42);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(6,20);
  ctx.lineTo(8,42);
  ctx.stroke();

  ctx.restore();
}

// ==========================================================
// LOOP
// ==========================================================
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="#222";
  for(const p of platforms) ctx.fillRect(p.x,p.y,p.w,p.h);

  player.update();
  enemies.forEach(e=>e.update());

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.update();
    if(b.life<=0) bullets.splice(i,1);

    if(!b.enemy){
      enemies.forEach(e=>{
        if(!e.dead &&
           b.x>e.x&&b.x<e.x+e.w&&
           b.y>e.y&&b.y<e.y+e.h){
          e.dead=true;
        }
      });
    }
  }

  bullets.forEach(b=>b.draw());
  drawHuman(player,false);
  enemies.forEach(e=>{
    if(e.dead){
      ctx.globalAlpha=e.fade/40;
      drawHuman(e,true);
      ctx.globalAlpha=1;
    }else drawHuman(e,true);
  });

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
