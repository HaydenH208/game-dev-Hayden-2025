<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pedro-Style FAT Demo (Stylized Gore)</title>
<style>
html,body{margin:0;background:#111;overflow:hidden}
canvas{display:block;margin:auto;background:#1a1a1a}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
// ==========================================================
// CANVAS
// ==========================================================
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
canvas.width = 1100;
canvas.height = 600;

// ==========================================================
// INPUT
// ==========================================================
const keys = {};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

const mouse={x:0,y:0,down:false};
canvas.onmousemove=e=>{
  const r=canvas.getBoundingClientRect();
  mouse.x=e.clientX-r.left;
  mouse.y=e.clientY-r.top;
};
canvas.onmousedown=()=>mouse.down=true;
canvas.onmouseup=()=>mouse.down=false;

// ==========================================================
// UTILS
// ==========================================================
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

// ==========================================================
// LEVEL
// ==========================================================
const platforms=[
  {x:0,y:540,w:2000,h:60},
  {x:300,y:420,w:300,h:20},
  {x:700,y:330,w:250,h:20}
];

// ==========================================================
// DECALS (BLOOD SHADOWS)
// ==========================================================
const decals=[];
function spawnDecal(x,y){
  decals.push({x,y,r:10+Math.random()*12,life:400});
}

// ==========================================================
// PARTICLES (STYLIZED BLOOD)
// ==========================================================
const particles=[];
class Particle{
  constructor(x,y){
    this.x=x;this.y=y;
    this.vx=(Math.random()-.5)*7;
    this.vy=(Math.random()-.8)*7;
    this.life=40;
  }
  update(){
    this.vy+=0.4;
    this.x+=this.vx;
    this.y+=this.vy;
    this.life--;
  }
  draw(){
    ctx.fillStyle="rgba(120,0,0,.8)";
    ctx.fillRect(this.x,this.y,3,3);
  }
}

// ==========================================================
// BULLETS
// ==========================================================
class Bullet{
  constructor(x,y,a,enemy=false){
    this.x=x;this.y=y;
    this.vx=Math.cos(a)*18;
    this.vy=Math.sin(a)*18;
    this.enemy=enemy;
    this.life=60;
    this.power=1;
  }
  update(){
    this.x+=this.vx;
    this.y+=this.vy;
    this.life--;
  }
  draw(){
    ctx.fillStyle=this.enemy?"#ff5555":"#00ffff";
    ctx.fillRect(this.x-2,this.y-2,4,4);
  }
}
const bullets=[];

// ==========================================================
// PLAYER
// ==========================================================
class Player{
  constructor(){
    this.x=100;this.y=300;
    this.w=30;this.h=60;
    this.vx=0;this.vy=0;
    this.onGround=false;
    this.cooldown=0;
  }
  update(){
    let dir=(keys["a"]?-1:0)+(keys["d"]?1:0);
    this.vx=dir*6;
    this.vy+=0.8;

    if(keys[" "]&&this.onGround){
      this.vy=-14;
      this.onGround=false;
    }

    this.x+=this.vx;
    this.y+=this.vy;

    this.onGround=false;
    for(const p of platforms){
      if(this.x+this.w>p.x && this.x<p.x+p.w){
        if(this.y+this.h<=p.y+10 && this.y+this.h+this.vy>=p.y){
          this.y=p.y-this.h;
          this.vy=0;
          this.onGround=true;
        }
      }
    }

    this.cooldown--;
    if(mouse.down && this.cooldown<=0){
      const cx=this.x+this.w/2;
      const cy=this.y+this.h*0.4;
      const a=Math.atan2(mouse.y-cy,mouse.x-cx);
      bullets.push(new Bullet(cx,cy,a,false));
      this.cooldown=6;
    }
  }
}
const player=new Player();

// ==========================================================
// ENEMY (DAMAGE, LIMBS, RAGDOLL-LITE)
// ==========================================================
class Enemy{
  constructor(x,y){
    this.x=x;this.y=y;
    this.w=30;this.h=60;
    this.dead=false;
    this.vy=0;
    this.rot=(Math.random()-.5)*0.8;

    this.parts={head:true,left:true,right:true};

    this.body=document.createElement("canvas");
    this.body.width=60;
    this.body.height=100;
    this.bctx=this.body.getContext("2d");
    this.redraw();
  }

  redraw(){
    const c=this.bctx;
    c.clearRect(0,0,60,100);

    c.fillStyle="#8b2a2a";
    roundRect(c,18,25,24,45,6);
    c.fill();

    if(this.parts.head){
      c.beginPath();
      c.arc(30,10,9,0,Math.PI*2);
      c.fillStyle="#b33";
      c.fill();
    }

    c.fillStyle="#8b2a2a";
    if(this.parts.left) c.fillRect(8,35,10,30);
    if(this.parts.right) c.fillRect(42,35,10,30);
  }

  hit(x,y){
    const ly=y-this.y;

    if(ly<15 && this.parts.head){
      this.parts.head=false;
      this.dead=true;
    }else if(ly<45){
      this.parts[Math.random()<0.5?"left":"right"]=false;
    }else{
      this.dead=true;
    }

    this.bctx.globalCompositeOperation="destination-out";
    this.bctx.beginPath();
    this.bctx.arc(x-this.x+30,y-this.y,10+Math.random()*6,0,Math.PI*2);
    this.bctx.fill();
    this.bctx.globalCompositeOperation="source-over";

    for(let i=0;i<14;i++) particles.push(new Particle(x,y));
    spawnDecal(x,y);
    this.redraw();
  }

  update(){
    if(this.dead){
      this.vy+=0.6;
      this.y+=this.vy;
      return;
    }

    const dx=player.x-this.x;
    const dy=player.y-this.y;
    if(Math.hypot(dx,dy)<400){
      if(Math.random()<0.01){
        bullets.push(new Bullet(this.x+15,this.y+30,Math.atan2(dy,dx),true));
      }
    }
  }

  draw(){
    ctx.save();
    ctx.translate(this.x+15,this.y+30);
    if(this.dead) ctx.rotate(this.rot);
    ctx.drawImage(this.body,-30,-50);
    ctx.restore();
  }
}
const enemies=[
  new Enemy(500,360),
  new Enemy(800,270)
];

// ==========================================================
// LOOP
// ==========================================================
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="#222";
  platforms.forEach(p=>ctx.fillRect(p.x,p.y,p.w,p.h));

  decals.forEach(d=>{
    ctx.fillStyle=`rgba(80,0,0,${d.life/400})`;
    ctx.beginPath();
    ctx.arc(d.x,d.y,d.r,0,Math.PI*2);
    ctx.fill();
    d.life--;
  });

  player.update();
  enemies.forEach(e=>e.update());

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.update();
    if(b.life<=0) bullets.splice(i,1);

    if(!b.enemy){
      enemies.forEach(e=>{
        if(!e.dead &&
           b.x>e.x && b.x<e.x+e.w &&
           b.y>e.y && b.y<e.y+e.h){
          e.hit(b.x,b.y);
          b.life=0;
        }
      });
    }
  }

  particles.forEach(p=>p.update());
  for(let i=particles.length-1;i>=0;i--) if(particles[i].life<=0) particles.splice(i,1);

  bullets.forEach(b=>b.draw());
  enemies.forEach(e=>e.draw());
  particles.forEach(p=>p.draw());

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
