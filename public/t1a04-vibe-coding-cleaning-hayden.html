<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Simple FPS Demo</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #222;
    color: white;
    font-family: monospace;
    user-select: none;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #333;
  }
  #score {
    position: absolute;
    top: 10px; left: 10px;
    font-size: 18px;
  }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="game" width="640" height="400"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  const mapSize = 10;

  // Simple map layout: 1 = wall, 0 = empty space
  const map = [
    1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,1,0,0,0,1,
    1,0,0,0,1,1,0,0,0,1,
    1,0,0,0,0,0,0,1,0,1,
    1,0,1,1,1,0,0,1,0,1,
    1,0,1,0,0,0,0,0,0,1,
    1,0,1,0,1,1,1,0,0,1,
    1,0,0,0,0,0,0,0,2,1,
    1,1,1,1,1,1,1,1,1,1,
  ];

  // Player state
  const player = {
    x: 2.5,
    y: 2.5,
    dir: 0, // angle in radians, 0 = east
    fov: Math.PI / 3, // 60 degrees
    speed: 0.05,
    rotSpeed: 0.04
  };

  // Targets to shoot (x,y in map coords)
  let targets = [
    {x: 8.5, y: 8.5, hit: false}
  ];

  let score = 0;
  const scoreDiv = document.getElementById('score');

  // Keyboard state
  const keys = {};

  document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  // Raycasting function
  function castRay(angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);

    let dist = 0;
    let hit = false;
    let wallX, wallY;

    while (!hit && dist < 20) {
      dist += 0.01;
      let x = player.x + cos * dist;
      let y = player.y + sin * dist;

      if (x < 0 || x >= mapSize || y < 0 || y >= mapSize) {
        hit = true;
        dist = 20;
      } else {
        let cell = map[Math.floor(y) * mapSize + Math.floor(x)];
        if (cell === 1) {
          hit = true;
          wallX = x;
          wallY = y;
        }
      }
    }
    return {dist, wallX, wallY};
  }

  // Draw walls with basic vertical lines
  function renderScene() {
    ctx.clearRect(0, 0, width, height);

    for (let x = 0; x < width; x++) {
      let rayAngle = (player.dir - player.fov / 2) + (x / width) * player.fov;
      let ray = castRay(rayAngle);
      // Correct fisheye effect:
      let correctedDist = ray.dist * Math.cos(rayAngle - player.dir);
      let wallHeight = Math.min(height, height / correctedDist);

      let shade = 255 - Math.min(255, correctedDist * 20);
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(x, height / 2 - wallHeight / 2, 1, wallHeight);
    }
  }

  // Draw targets as red circles on screen (simplified)
  function renderTargets() {
    targets.forEach(t => {
      if (t.hit) return;
      // Calculate relative angle and distance
      let dx = t.x - player.x;
      let dy = t.y - player.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      let angleToTarget = Math.atan2(dy, dx);

      let relativeAngle = angleToTarget - player.dir;

      // Normalize relativeAngle to [-PI, PI]
      while (relativeAngle > Math.PI) relativeAngle -= 2 * Math.PI;
      while (relativeAngle < -Math.PI) relativeAngle += 2 * Math.PI;

      if (Math.abs(relativeAngle) < player.fov / 2) {
        // Project x on screen
        let screenX = (relativeAngle + player.fov/2) / player.fov * width;
        let size = 100 / dist;
        if(size > 0 && size < 50){
          ctx.beginPath();
          ctx.fillStyle = 'red';
          ctx.arc(screenX, height/2, size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    });
  }

  // Move player based on keys
  function updatePlayer() {
    if (keys['a']) {
      // Strafe left
      let nx = player.x + Math.cos(player.dir - Math.PI/2) * player.speed;
      let ny = player.y + Math.sin(player.dir - Math.PI/2) * player.speed;
      if(map[Math.floor(ny)*mapSize + Math.floor(nx)] === 0) {
        player.x = nx;
        player.y = ny;
      }
    }
    if (keys['d']) {
      // Strafe right
      let nx = player.x + Math.cos(player.dir + Math.PI/2) * player.speed;
      let ny = player.y + Math.sin(player.dir + Math.PI/2) * player.speed;
      if(map[Math.floor(ny)*mapSize + Math.floor(nx)] === 0) {
        player.x = nx;
        player.y = ny;
      }
    }
    if (keys['w']) {
      // Forward
      let nx = player.x + Math.cos(player.dir) * player.speed;
      let ny = player.y + Math.sin(player.dir) * player.speed;
      if(map[Math.floor(ny)*mapSize + Math.floor(nx)] === 0) {
        player.x = nx;
        player.y = ny;
      }
    }
    if (keys['s']) {
      // Backward
      let nx = player.x - Math.cos(player.dir) * player.speed;
      let ny = player.y - Math.sin(player.dir) * player.speed;
      if(map[Math.floor(ny)*mapSize + Math.floor(nx)] === 0) {
        player.x = nx;
        player.y = ny;
      }
    }
    if (keys['arrowleft']) {
      player.dir -= player.rotSpeed;
    }
    if (keys['arrowright']) {
      player.dir += player.rotSpeed;
    }
  }

  // Shooting mechanic: spacebar to shoot
  function shoot() {
    // Cast a ray forward and check if it hits target within range
    let ray = castRay(player.dir);

    targets.forEach(t => {
      if (t.hit) return;
      // Distance to target
      let dx = t.x - player.x;
      let dy = t.y - player.y;
      let distToTarget = Math.sqrt(dx*dx + dy*dy);
      // Angle to target
      let angleToTarget = Math.atan2(dy, dx);
      let angleDiff = Math.abs(angleToTarget - player.dir);
      while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      angleDiff = Math.abs(angleDiff);

      if (distToTarget < ray.dist + 0.3 && distToTarget < 6 && angleDiff < 0.1) {
        t.hit = true;
        score++;
        scoreDiv.textContent = 'Score: ' + score;
      }
    });

    // Flash effect (simple)
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fillRect(0, 0, width, height);
  }

  // Shoot on spacebar press (debounced)
  let canShoot = true;
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && canShoot) {
      shoot();
      canShoot = false;
      setTimeout(() => canShoot = true, 300);
      e.preventDefault();
    }
  });

  function gameLoop() {
    updatePlayer();
    renderScene();
    renderTargets();

    requestAnimationFrame(gameLoop);
  }

  gameLoop();
})();
</script>
</body>
</html>
